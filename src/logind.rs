// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

use dbus::arg;
use dbus::blocking;

pub trait OrgFreedesktopDBusPeer {
	fn ping(&self) -> Result<(), dbus::Error>;
	fn get_machine_id(&self) -> Result<String, dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target = blocking::Connection>> OrgFreedesktopDBusPeer for blocking::Proxy<'a, C> {
	fn ping(&self) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.DBus.Peer", "Ping", ())
	}

	fn get_machine_id(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.DBus.Peer", "GetMachineId", ())
			.and_then(|r: (String,)| Ok(r.0))
	}
}

pub trait OrgFreedesktopDBusIntrospectable {
	fn introspect(&self) -> Result<String, dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target = blocking::Connection>> OrgFreedesktopDBusIntrospectable
	for blocking::Proxy<'a, C>
{
	fn introspect(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.DBus.Introspectable", "Introspect", ())
			.and_then(|r: (String,)| Ok(r.0))
	}
}

pub trait OrgFreedesktopDBusProperties {
	fn get<R0: for<'b> arg::Get<'b>>(&self, interface: &str, property: &str) -> Result<arg::Variant<R0>, dbus::Error>;
	fn get_all(
		&self,
		interface: &str,
	) -> Result<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error>;
	fn set<I2: arg::Arg + arg::Append>(
		&self,
		interface: &str,
		property: &str,
		value: arg::Variant<I2>,
	) -> Result<(), dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target = blocking::Connection>> OrgFreedesktopDBusProperties for blocking::Proxy<'a, C> {
	fn get<R0: for<'b> arg::Get<'b>>(&self, interface: &str, property: &str) -> Result<arg::Variant<R0>, dbus::Error> {
		self.method_call("org.freedesktop.DBus.Properties", "Get", (interface, property))
			.and_then(|r: (arg::Variant<R0>,)| Ok(r.0))
	}

	fn get_all(
		&self,
		interface: &str,
	) -> Result<::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error> {
		self.method_call("org.freedesktop.DBus.Properties", "GetAll", (interface,))
			.and_then(|r: (::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,)| Ok(r.0))
	}

	fn set<I2: arg::Arg + arg::Append>(
		&self,
		interface: &str,
		property: &str,
		value: arg::Variant<I2>,
	) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.DBus.Properties", "Set", (interface, property, value))
	}
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
	pub interface: String,
	pub changed_properties: ::std::collections::HashMap<String, arg::Variant<Box<dyn arg::RefArg + 'static>>>,
	pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
	fn append(&self, i: &mut arg::IterAppend) {
		arg::RefArg::append(&self.interface, i);
		arg::RefArg::append(&self.changed_properties, i);
		arg::RefArg::append(&self.invalidated_properties, i);
	}
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
	fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
		Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
			interface: i.read()?,
			changed_properties: i.read()?,
			invalidated_properties: i.read()?,
		})
	}
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
	const NAME: &'static str = "PropertiesChanged";
	const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

pub trait OrgFreedesktopLogin1Manager {
	fn get_session(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error>;
	fn get_session_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error>;
	fn get_user(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error>;
	fn get_user_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error>;
	fn get_seat(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error>;
	fn list_sessions(&self) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, dbus::Error>;
	fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, dbus::Error>;
	fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::Error>;
	fn list_inhibitors(&self) -> Result<Vec<(String, String, String, String, u32, u32)>, dbus::Error>;
	fn create_session(
		&self,
		arg0: u32,
		arg1: u32,
		arg2: &str,
		arg3: &str,
		arg4: &str,
		arg5: &str,
		arg6: &str,
		arg7: u32,
		arg8: &str,
		arg9: &str,
		arg10: bool,
		arg11: &str,
		arg12: &str,
		arg13: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>,
	) -> Result<
		(
			String,
			dbus::Path<'static>,
			String,
			dbus::arg::OwnedFd,
			u32,
			String,
			u32,
			bool,
		),
		dbus::Error,
	>;
	fn release_session(&self, arg0: &str) -> Result<(), dbus::Error>;
	fn activate_session(&self, arg0: &str) -> Result<(), dbus::Error>;
	fn activate_session_on_seat(&self, arg0: &str, arg1: &str) -> Result<(), dbus::Error>;
	fn lock_session(&self, arg0: &str) -> Result<(), dbus::Error>;
	fn unlock_session(&self, arg0: &str) -> Result<(), dbus::Error>;
	fn lock_sessions(&self) -> Result<(), dbus::Error>;
	fn unlock_sessions(&self) -> Result<(), dbus::Error>;
	fn kill_session(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), dbus::Error>;
	fn kill_user(&self, arg0: u32, arg1: i32) -> Result<(), dbus::Error>;
	fn terminate_session(&self, arg0: &str) -> Result<(), dbus::Error>;
	fn terminate_user(&self, arg0: u32) -> Result<(), dbus::Error>;
	fn terminate_seat(&self, arg0: &str) -> Result<(), dbus::Error>;
	fn set_user_linger(&self, arg0: u32, arg1: bool, arg2: bool) -> Result<(), dbus::Error>;
	fn attach_device(&self, arg0: &str, arg1: &str, arg2: bool) -> Result<(), dbus::Error>;
	fn flush_devices(&self, arg0: bool) -> Result<(), dbus::Error>;
	fn power_off(&self, arg0: bool) -> Result<(), dbus::Error>;
	fn reboot(&self, arg0: bool) -> Result<(), dbus::Error>;
	fn halt(&self, arg0: bool) -> Result<(), dbus::Error>;
	fn suspend(&self, arg0: bool) -> Result<(), dbus::Error>;
	fn hibernate(&self, arg0: bool) -> Result<(), dbus::Error>;
	fn hybrid_sleep(&self, arg0: bool) -> Result<(), dbus::Error>;
	fn suspend_then_hibernate(&self, arg0: bool) -> Result<(), dbus::Error>;
	fn can_power_off(&self) -> Result<String, dbus::Error>;
	fn can_reboot(&self) -> Result<String, dbus::Error>;
	fn can_halt(&self) -> Result<String, dbus::Error>;
	fn can_suspend(&self) -> Result<String, dbus::Error>;
	fn can_hibernate(&self) -> Result<String, dbus::Error>;
	fn can_hybrid_sleep(&self) -> Result<String, dbus::Error>;
	fn can_suspend_then_hibernate(&self) -> Result<String, dbus::Error>;
	fn schedule_shutdown(&self, arg0: &str, arg1: u64) -> Result<(), dbus::Error>;
	fn cancel_scheduled_shutdown(&self) -> Result<bool, dbus::Error>;
	fn inhibit(&self, arg0: &str, arg1: &str, arg2: &str, arg3: &str) -> Result<dbus::arg::OwnedFd, dbus::Error>;
	fn can_reboot_parameter(&self) -> Result<String, dbus::Error>;
	fn set_reboot_parameter(&self, arg0: &str) -> Result<(), dbus::Error>;
	fn can_reboot_to_firmware_setup(&self) -> Result<String, dbus::Error>;
	fn set_reboot_to_firmware_setup(&self, arg0: bool) -> Result<(), dbus::Error>;
	fn can_reboot_to_boot_loader_menu(&self) -> Result<String, dbus::Error>;
	fn set_reboot_to_boot_loader_menu(&self, arg0: u64) -> Result<(), dbus::Error>;
	fn can_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error>;
	fn set_reboot_to_boot_loader_entry(&self, arg0: &str) -> Result<(), dbus::Error>;
	fn get_enable_wall_messages(&self) -> Result<bool, dbus::Error>;
	fn set_enable_wall_messages(&self, value: bool) -> Result<(), dbus::Error>;
	fn get_wall_message(&self) -> Result<String, dbus::Error>;
	fn set_wall_message(&self, value: String) -> Result<(), dbus::Error>;
	fn get_nauto_vts(&self) -> Result<u32, dbus::Error>;
	fn get_kill_only_users(&self) -> Result<Vec<String>, dbus::Error>;
	fn get_kill_exclude_users(&self) -> Result<Vec<String>, dbus::Error>;
	fn get_kill_user_processes(&self) -> Result<bool, dbus::Error>;
	fn get_reboot_parameter(&self) -> Result<String, dbus::Error>;
	fn get_reboot_to_firmware_setup(&self) -> Result<bool, dbus::Error>;
	fn get_reboot_to_boot_loader_menu(&self) -> Result<u64, dbus::Error>;
	fn get_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error>;
	fn get_boot_loader_entries(&self) -> Result<Vec<String>, dbus::Error>;
	fn get_idle_hint(&self) -> Result<bool, dbus::Error>;
	fn get_idle_since_hint(&self) -> Result<u64, dbus::Error>;
	fn get_idle_since_hint_monotonic(&self) -> Result<u64, dbus::Error>;
	fn get_block_inhibited(&self) -> Result<String, dbus::Error>;
	fn get_delay_inhibited(&self) -> Result<String, dbus::Error>;
	fn get_inhibit_delay_max_usec(&self) -> Result<u64, dbus::Error>;
	fn get_user_stop_delay_usec(&self) -> Result<u64, dbus::Error>;
	fn get_handle_power_key(&self) -> Result<String, dbus::Error>;
	fn get_handle_suspend_key(&self) -> Result<String, dbus::Error>;
	fn get_handle_hibernate_key(&self) -> Result<String, dbus::Error>;
	fn get_handle_lid_switch(&self) -> Result<String, dbus::Error>;
	fn get_handle_lid_switch_external_power(&self) -> Result<String, dbus::Error>;
	fn get_handle_lid_switch_docked(&self) -> Result<String, dbus::Error>;
	fn get_holdoff_timeout_usec(&self) -> Result<u64, dbus::Error>;
	fn get_idle_action(&self) -> Result<String, dbus::Error>;
	fn get_idle_action_usec(&self) -> Result<u64, dbus::Error>;
	fn get_preparing_for_shutdown(&self) -> Result<bool, dbus::Error>;
	fn get_preparing_for_sleep(&self) -> Result<bool, dbus::Error>;
	fn get_scheduled_shutdown(&self) -> Result<(String, u64), dbus::Error>;
	fn get_docked(&self) -> Result<bool, dbus::Error>;
	fn get_lid_closed(&self) -> Result<bool, dbus::Error>;
	fn get_on_external_power(&self) -> Result<bool, dbus::Error>;
	fn get_remove_ipc(&self) -> Result<bool, dbus::Error>;
	fn get_runtime_directory_size(&self) -> Result<u64, dbus::Error>;
	fn get_inhibitors_max(&self) -> Result<u64, dbus::Error>;
	fn get_ncurrent_inhibitors(&self) -> Result<u64, dbus::Error>;
	fn get_sessions_max(&self) -> Result<u64, dbus::Error>;
	fn get_ncurrent_sessions(&self) -> Result<u64, dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target = blocking::Connection>> OrgFreedesktopLogin1Manager for blocking::Proxy<'a, C> {
	fn get_session(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "GetSession", (arg0,))
			.and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
	}

	fn get_session_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "GetSessionByPID", (arg0,))
			.and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
	}

	fn get_user(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "GetUser", (arg0,))
			.and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
	}

	fn get_user_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "GetUserByPID", (arg0,))
			.and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
	}

	fn get_seat(&self, arg0: &str) -> Result<dbus::Path<'static>, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "GetSeat", (arg0,))
			.and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
	}

	fn list_sessions(&self) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "ListSessions", ())
			.and_then(|r: (Vec<(String, u32, String, String, dbus::Path<'static>)>,)| Ok(r.0))
	}

	fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "ListUsers", ())
			.and_then(|r: (Vec<(u32, String, dbus::Path<'static>)>,)| Ok(r.0))
	}

	fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "ListSeats", ())
			.and_then(|r: (Vec<(String, dbus::Path<'static>)>,)| Ok(r.0))
	}

	fn list_inhibitors(&self) -> Result<Vec<(String, String, String, String, u32, u32)>, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "ListInhibitors", ())
			.and_then(|r: (Vec<(String, String, String, String, u32, u32)>,)| Ok(r.0))
	}

	fn create_session(
		&self,
		arg0: u32,
		arg1: u32,
		arg2: &str,
		arg3: &str,
		arg4: &str,
		arg5: &str,
		arg6: &str,
		arg7: u32,
		arg8: &str,
		arg9: &str,
		arg10: bool,
		arg11: &str,
		arg12: &str,
		arg13: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>,
	) -> Result<
		(
			String,
			dbus::Path<'static>,
			String,
			dbus::arg::OwnedFd,
			u32,
			String,
			u32,
			bool,
		),
		dbus::Error,
	> {
		self.method_call(
			"org.freedesktop.login1.Manager",
			"CreateSession",
			(
				arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13,
			),
		)
	}

	fn release_session(&self, arg0: &str) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "ReleaseSession", (arg0,))
	}

	fn activate_session(&self, arg0: &str) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "ActivateSession", (arg0,))
	}

	fn activate_session_on_seat(&self, arg0: &str, arg1: &str) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "ActivateSessionOnSeat", (arg0, arg1))
	}

	fn lock_session(&self, arg0: &str) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "LockSession", (arg0,))
	}

	fn unlock_session(&self, arg0: &str) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "UnlockSession", (arg0,))
	}

	fn lock_sessions(&self) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "LockSessions", ())
	}

	fn unlock_sessions(&self) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "UnlockSessions", ())
	}

	fn kill_session(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "KillSession", (arg0, arg1, arg2))
	}

	fn kill_user(&self, arg0: u32, arg1: i32) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "KillUser", (arg0, arg1))
	}

	fn terminate_session(&self, arg0: &str) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "TerminateSession", (arg0,))
	}

	fn terminate_user(&self, arg0: u32) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "TerminateUser", (arg0,))
	}

	fn terminate_seat(&self, arg0: &str) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "TerminateSeat", (arg0,))
	}

	fn set_user_linger(&self, arg0: u32, arg1: bool, arg2: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "SetUserLinger", (arg0, arg1, arg2))
	}

	fn attach_device(&self, arg0: &str, arg1: &str, arg2: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "AttachDevice", (arg0, arg1, arg2))
	}

	fn flush_devices(&self, arg0: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "FlushDevices", (arg0,))
	}

	fn power_off(&self, arg0: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "PowerOff", (arg0,))
	}

	fn reboot(&self, arg0: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "Reboot", (arg0,))
	}

	fn halt(&self, arg0: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "Halt", (arg0,))
	}

	fn suspend(&self, arg0: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "Suspend", (arg0,))
	}

	fn hibernate(&self, arg0: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "Hibernate", (arg0,))
	}

	fn hybrid_sleep(&self, arg0: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "HybridSleep", (arg0,))
	}

	fn suspend_then_hibernate(&self, arg0: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "SuspendThenHibernate", (arg0,))
	}

	fn can_power_off(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanPowerOff", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn can_reboot(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanReboot", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn can_halt(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanHalt", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn can_suspend(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanSuspend", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn can_hibernate(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanHibernate", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn can_hybrid_sleep(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanHybridSleep", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn can_suspend_then_hibernate(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanSuspendThenHibernate", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn schedule_shutdown(&self, arg0: &str, arg1: u64) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "ScheduleShutdown", (arg0, arg1))
	}

	fn cancel_scheduled_shutdown(&self) -> Result<bool, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CancelScheduledShutdown", ())
			.and_then(|r: (bool,)| Ok(r.0))
	}

	fn inhibit(&self, arg0: &str, arg1: &str, arg2: &str, arg3: &str) -> Result<dbus::arg::OwnedFd, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "Inhibit", (arg0, arg1, arg2, arg3))
			.and_then(|r: (dbus::arg::OwnedFd,)| Ok(r.0))
	}

	fn can_reboot_parameter(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanRebootParameter", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn set_reboot_parameter(&self, arg0: &str) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "SetRebootParameter", (arg0,))
	}

	fn can_reboot_to_firmware_setup(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanRebootToFirmwareSetup", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn set_reboot_to_firmware_setup(&self, arg0: bool) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "SetRebootToFirmwareSetup", (arg0,))
	}

	fn can_reboot_to_boot_loader_menu(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanRebootToBootLoaderMenu", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn set_reboot_to_boot_loader_menu(&self, arg0: u64) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "SetRebootToBootLoaderMenu", (arg0,))
	}

	fn can_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "CanRebootToBootLoaderEntry", ())
			.and_then(|r: (String,)| Ok(r.0))
	}

	fn set_reboot_to_boot_loader_entry(&self, arg0: &str) -> Result<(), dbus::Error> {
		self.method_call("org.freedesktop.login1.Manager", "SetRebootToBootLoaderEntry", (arg0,))
	}

	fn get_enable_wall_messages(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"EnableWallMessages",
		)
	}

	fn get_wall_message(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"WallMessage",
		)
	}

	fn get_nauto_vts(&self) -> Result<u32, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"NAutoVTs",
		)
	}

	fn get_kill_only_users(&self) -> Result<Vec<String>, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"KillOnlyUsers",
		)
	}

	fn get_kill_exclude_users(&self) -> Result<Vec<String>, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"KillExcludeUsers",
		)
	}

	fn get_kill_user_processes(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"KillUserProcesses",
		)
	}

	fn get_reboot_parameter(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"RebootParameter",
		)
	}

	fn get_reboot_to_firmware_setup(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"RebootToFirmwareSetup",
		)
	}

	fn get_reboot_to_boot_loader_menu(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"RebootToBootLoaderMenu",
		)
	}

	fn get_reboot_to_boot_loader_entry(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"RebootToBootLoaderEntry",
		)
	}

	fn get_boot_loader_entries(&self) -> Result<Vec<String>, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"BootLoaderEntries",
		)
	}

	fn get_idle_hint(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"IdleHint",
		)
	}

	fn get_idle_since_hint(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"IdleSinceHint",
		)
	}

	fn get_idle_since_hint_monotonic(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"IdleSinceHintMonotonic",
		)
	}

	fn get_block_inhibited(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"BlockInhibited",
		)
	}

	fn get_delay_inhibited(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"DelayInhibited",
		)
	}

	fn get_inhibit_delay_max_usec(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"InhibitDelayMaxUSec",
		)
	}

	fn get_user_stop_delay_usec(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"UserStopDelayUSec",
		)
	}

	fn get_handle_power_key(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"HandlePowerKey",
		)
	}

	fn get_handle_suspend_key(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"HandleSuspendKey",
		)
	}

	fn get_handle_hibernate_key(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"HandleHibernateKey",
		)
	}

	fn get_handle_lid_switch(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"HandleLidSwitch",
		)
	}

	fn get_handle_lid_switch_external_power(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"HandleLidSwitchExternalPower",
		)
	}

	fn get_handle_lid_switch_docked(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"HandleLidSwitchDocked",
		)
	}

	fn get_holdoff_timeout_usec(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"HoldoffTimeoutUSec",
		)
	}

	fn get_idle_action(&self) -> Result<String, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"IdleAction",
		)
	}

	fn get_idle_action_usec(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"IdleActionUSec",
		)
	}

	fn get_preparing_for_shutdown(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"PreparingForShutdown",
		)
	}

	fn get_preparing_for_sleep(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"PreparingForSleep",
		)
	}

	fn get_scheduled_shutdown(&self) -> Result<(String, u64), dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"ScheduledShutdown",
		)
	}

	fn get_docked(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"Docked",
		)
	}

	fn get_lid_closed(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"LidClosed",
		)
	}

	fn get_on_external_power(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"OnExternalPower",
		)
	}

	fn get_remove_ipc(&self) -> Result<bool, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"RemoveIPC",
		)
	}

	fn get_runtime_directory_size(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"RuntimeDirectorySize",
		)
	}

	fn get_inhibitors_max(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"InhibitorsMax",
		)
	}

	fn get_ncurrent_inhibitors(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"NCurrentInhibitors",
		)
	}

	fn get_sessions_max(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"SessionsMax",
		)
	}

	fn get_ncurrent_sessions(&self) -> Result<u64, dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
			&self,
			"org.freedesktop.login1.Manager",
			"NCurrentSessions",
		)
	}

	fn set_enable_wall_messages(&self, value: bool) -> Result<(), dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::set(
			&self,
			"org.freedesktop.login1.Manager",
			"EnableWallMessages",
			value,
		)
	}

	fn set_wall_message(&self, value: String) -> Result<(), dbus::Error> {
		<Self as blocking::stdintf::org_freedesktop_dbus::Properties>::set(
			&self,
			"org.freedesktop.login1.Manager",
			"WallMessage",
			value,
		)
	}
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSessionNew {
	pub arg0: String,
	pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSessionNew {
	fn append(&self, i: &mut arg::IterAppend) {
		arg::RefArg::append(&self.arg0, i);
		arg::RefArg::append(&self.arg1, i);
	}
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSessionNew {
	fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
		Ok(OrgFreedesktopLogin1ManagerSessionNew {
			arg0: i.read()?,
			arg1: i.read()?,
		})
	}
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSessionNew {
	const NAME: &'static str = "SessionNew";
	const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSessionRemoved {
	pub arg0: String,
	pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSessionRemoved {
	fn append(&self, i: &mut arg::IterAppend) {
		arg::RefArg::append(&self.arg0, i);
		arg::RefArg::append(&self.arg1, i);
	}
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSessionRemoved {
	fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
		Ok(OrgFreedesktopLogin1ManagerSessionRemoved {
			arg0: i.read()?,
			arg1: i.read()?,
		})
	}
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSessionRemoved {
	const NAME: &'static str = "SessionRemoved";
	const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerUserNew {
	pub arg0: u32,
	pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerUserNew {
	fn append(&self, i: &mut arg::IterAppend) {
		arg::RefArg::append(&self.arg0, i);
		arg::RefArg::append(&self.arg1, i);
	}
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerUserNew {
	fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
		Ok(OrgFreedesktopLogin1ManagerUserNew {
			arg0: i.read()?,
			arg1: i.read()?,
		})
	}
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerUserNew {
	const NAME: &'static str = "UserNew";
	const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerUserRemoved {
	pub arg0: u32,
	pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerUserRemoved {
	fn append(&self, i: &mut arg::IterAppend) {
		arg::RefArg::append(&self.arg0, i);
		arg::RefArg::append(&self.arg1, i);
	}
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerUserRemoved {
	fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
		Ok(OrgFreedesktopLogin1ManagerUserRemoved {
			arg0: i.read()?,
			arg1: i.read()?,
		})
	}
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerUserRemoved {
	const NAME: &'static str = "UserRemoved";
	const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSeatNew {
	pub arg0: String,
	pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSeatNew {
	fn append(&self, i: &mut arg::IterAppend) {
		arg::RefArg::append(&self.arg0, i);
		arg::RefArg::append(&self.arg1, i);
	}
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSeatNew {
	fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
		Ok(OrgFreedesktopLogin1ManagerSeatNew {
			arg0: i.read()?,
			arg1: i.read()?,
		})
	}
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSeatNew {
	const NAME: &'static str = "SeatNew";
	const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerSeatRemoved {
	pub arg0: String,
	pub arg1: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerSeatRemoved {
	fn append(&self, i: &mut arg::IterAppend) {
		arg::RefArg::append(&self.arg0, i);
		arg::RefArg::append(&self.arg1, i);
	}
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerSeatRemoved {
	fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
		Ok(OrgFreedesktopLogin1ManagerSeatRemoved {
			arg0: i.read()?,
			arg1: i.read()?,
		})
	}
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerSeatRemoved {
	const NAME: &'static str = "SeatRemoved";
	const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerPrepareForShutdown {
	pub arg0: bool,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerPrepareForShutdown {
	fn append(&self, i: &mut arg::IterAppend) {
		arg::RefArg::append(&self.arg0, i);
	}
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerPrepareForShutdown {
	fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
		Ok(OrgFreedesktopLogin1ManagerPrepareForShutdown { arg0: i.read()? })
	}
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForShutdown {
	const NAME: &'static str = "PrepareForShutdown";
	const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopLogin1ManagerPrepareForSleep {
	pub arg0: bool,
}

impl arg::AppendAll for OrgFreedesktopLogin1ManagerPrepareForSleep {
	fn append(&self, i: &mut arg::IterAppend) {
		arg::RefArg::append(&self.arg0, i);
	}
}

impl arg::ReadAll for OrgFreedesktopLogin1ManagerPrepareForSleep {
	fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
		Ok(OrgFreedesktopLogin1ManagerPrepareForSleep { arg0: i.read()? })
	}
}

impl dbus::message::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForSleep {
	const NAME: &'static str = "PrepareForSleep";
	const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
}
